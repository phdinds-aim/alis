{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "520c157a",
   "metadata": {},
   "source": [
    "# LSH Banding Technique"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ce2b3905",
   "metadata": {},
   "source": [
    "In this section, we discuss the more traditional approach to LSH which follows the workflow of ***shingling $\\rightarrow$ minhashing $\\rightarrow$ banding*** (*the actual LSH step*).\n",
    "\n",
    "Recall: We can express documents as *k*-shingles (or whichever token we choose) and consequently perform a mminhashing to obtain signatures. We arrange these into columns of a matrix--where rows correspond to each item of a signature. Also, suppose that the signatures now have invariant lengths (i.e., number of rows) due to the prior 'preprocessing' done.\n",
    "\n",
    "We obtain a structure similar to what is shown below:\n",
    "\n",
    "```{figure} ./images/band_structure.PNG\n",
    ":name: band-structure\n",
    "\n",
    "Segmented signature matrix. Four segments/bands with three rows per segment. Taken from {cite:ps}`rajaraman2011mining`.\n",
    "```\n",
    "\n",
    "Notice that unlike those discussed in Minhashing, this signature matrix are now segmented into bands containing three (3) rows per band. Why do this?\n",
    "\n",
    "Let's break it down. If we simply apply a hash function to full signatures then it will most likely be that we will only get the completely identical signatures--losing pairs that hold some similarity (i.e., candidate pairs) in some segments of their respective signatures. *Note: We end up discarding similar but not identical documents.* This presents another compelling reason for the banded LSH approach.\n",
    "\n",
    "A natural course to this is to \"hash\" the items several times using different hash functions banking on the idea that similar items will more likely be hashed to the same bucket--otherwise, dissimilar items. The book terminology for items hashed into the same buckets are *candidate pairs*. Narrowing down the search? Voila! *Candidate pairs* instead of that $n \\choose 2$ number of pairs.\n",
    "\n",
    "Alternatively, for minhashed signatures like the one shown in {numref}`band-structure`, hashing can be applied per band/segment. Hash functions can either be varied per band/segment or the same. In effect, multiple hashing and/or segmented hashing addresses the overfit on getting only identical but not similar items.\n",
    "\n",
    "Banded signatures are then hashed, forming different hash tables for each band. Candidate pairs are then determined according to those hashed in the same buckets. See {numref}`bandhash-mechanics` for the underlying mechanics.\n",
    "\n",
    "```{figure} ./images/bandhash_mechanics.PNG\n",
    ":width: 700px\n",
    ":name: bandhash-mechanics\n",
    "\n",
    "Underlying mechanics of the \"Band Hashing\" method for two banded signature sets $a$ and $b$. In this figure, A and B are considered as candidate pairs because their 3rd bands are hashed in the same buckets. Here only one hash function is used but bands get their own set of hash buckets.\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "26b50f7b",
   "metadata": {},
   "source": [
    "Following a more tolerant approach wherein any pair are classified as *candidate pairs* as long as they are hashed in the same bucket in any of the bands formed, hence number of bands and the resulting number of rows in each band as a tuning parameter. Wherein more number of bands will increase the probability of any pair--despite having low similarity--to be tagged as *candidate pairs*. We then state that the number of bands determine the similarity threshold as shown below--where document pairs with pairwise similarities above the threshold (dashed line) will be tagged as *candidate pairs*."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "370d67b0",
   "metadata": {
    "ExecuteTime": {
     "end_time": "2022-04-01T17:16:33.505768Z",
     "start_time": "2022-04-01T17:16:32.343235Z"
    },
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "030b69ab8df444198fafe5b0251e0fbe",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "VBox(children=(IntText(value=100, description='Signature\\nSize (m)', layout=Layout(height='40px', width='25%')â€¦"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "from ipywidgets import widgets, interact\n",
    "import numpy as np\n",
    "\n",
    "import plotly.graph_objects as go\n",
    "\n",
    "\n",
    "def _get_factors(x):\n",
    "    factors = []\n",
    "    for i in range(1, x + 1):\n",
    "        if x % i == 0:\n",
    "            factors.append(x)\n",
    "    return factors\n",
    "\n",
    "def _get_valinit(factors):\n",
    "    index = len(factors) // 2 \n",
    "    return factors[index]\n",
    "\n",
    "def _prob_of_s(s, b, r):\n",
    "    \"\"\"Return the probability of similarity s given b and r\"\"\"\n",
    "    return 1 - (1 - s**r)**b\n",
    "\n",
    "def _get_approx_thresh(b, r):\n",
    "    \"\"\"Return approximate similarity threshold for chosen b and r\"\"\"\n",
    "    thresh = (1/b) ** (1/r)\n",
    "    return thresh\n",
    "\n",
    "# plotting\n",
    "init_m = 100\n",
    "init_b_value = init_m // 2\n",
    "\n",
    "# fig, ax = plt.subplots(figsize=(10, 5))\n",
    "style = {'description_width': 'initial',\n",
    "         'handle_color' : 'deeppink',\n",
    "         'font_weight': 'bold',\n",
    "         'text_color' : 'darkstalegray'}\n",
    "\n",
    "b_widget = widgets.IntSlider(\n",
    "    description='Number of Bands (b)',\n",
    "    value=init_b_value,\n",
    "    min=1,\n",
    "    max=init_m,\n",
    "    continuous_update=True,\n",
    "    orientation='horizontal',\n",
    "    readout=True,\n",
    "    disabled=False,\n",
    "    layout=widgets.Layout(width='50%', height='10px'),\n",
    "    style=style\n",
    ")\n",
    "\n",
    "size_widget = widgets.IntText(\n",
    "    value=init_m,\n",
    "    description='Signature\\nSize (m)',\n",
    "    disabled=False,\n",
    "    continous_update=True,\n",
    "    layout=widgets.Layout(width='25%', height='40px'),\n",
    "    style=style\n",
    ")\n",
    "\n",
    "r_init = init_m / init_b_value\n",
    "init_thresh = _get_approx_thresh(init_b_value, r_init)\n",
    "\n",
    "s_list = np.linspace(0, 1, num=100)\n",
    "p_list = np.array([_prob_of_s(s, init_b_value, r_init) for s in s_list])\n",
    "data = [go.Scatter(x=s_list, y=p_list, name='S-curve',marker_color='deeppink', line_width=4)]\n",
    "g = go.FigureWidget(\n",
    "    data=data,)\n",
    "\n",
    "g.add_vline(init_thresh, line_dash=\"dash\", line_width=3, \n",
    "            annotation=dict(text=f'Similarity Threshold {init_thresh:.2f}'), \n",
    "            annotation_x=1, annotation_xanchor=\"right\",\n",
    "            annotation_y=0, annotation_yanchor=\"bottom\",\n",
    "            annotation_font_size=12)\n",
    "g.layout.height = 500\n",
    "g.layout.width = 700\n",
    "g.layout.title = 'Probability of becoming a candidate given a similarity\\nThe S-curve'\n",
    "g.layout.xaxis.title = 'Jaccard Similarity of Documents'\n",
    "g.layout.yaxis.title = 'Probability'\n",
    "\n",
    "\n",
    "def update_b_range(*args):\n",
    "    b_widget.max = size_widget.value\n",
    "    \n",
    "    b = b_widget.value\n",
    "    r = size_widget.value / b\n",
    "    with g.batch_update():\n",
    "        g.data[0].y = np.array([_prob_of_s(s, b, r) for s in s_list])\n",
    "        new_thresh = _get_approx_thresh(b, r)\n",
    "        g.update_shapes(x0=new_thresh, x1=new_thresh,)\n",
    "        g.update_annotations(dict(text=f'Similarity Threshold {new_thresh:.2f}'))\n",
    "size_widget.observe(update_b_range, names='value')\n",
    "b_widget.observe(update_b_range, names='value')\n",
    "\n",
    "widgets.VBox([size_widget,b_widget, g])"
   ]
  }
 ],
 "metadata": {
  "celltoolbar": "Tags",
  "hide_input": false,
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.6"
  },
  "toc": {
   "base_numbering": 1,
   "nav_menu": {},
   "number_sections": true,
   "sideBar": true,
   "skip_h1_title": false,
   "title_cell": "Table of Contents",
   "title_sidebar": "Contents",
   "toc_cell": false,
   "toc_position": {},
   "toc_section_display": true,
   "toc_window_display": false
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
